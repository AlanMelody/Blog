<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Seite 3 | Jack Alan</title>
  <meta name="author" content="Jack Alan">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Jack Alan"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Jack Alan" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" href="/css/style.css">
  <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/Books&Courses">Books &amp; Courses</a></li>
    
      <li><a href="/Links">Friends</a></li>
    
      <li><a href="/AboutMe">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://115.28.103.52/bingimage/bing.php">
		<a href="/">
			<div class="logo">
				<img src="/logo.png" alt="Profile Picture">
			</div>
			<div id="title">Jack Alan</div>
		</a>

		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/AlanMelody" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/iAlanMelody" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
 <li>
   	<a href="mailto:jack@iJack.pw" class="email" target="_blank" title="Email Me">
  		<i class="fa fa-envelope"></i>
  	</a>
 </li>
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-12-30T03:41:19.000Z"><a href="/2015/12/29/浅谈iOS中的内存管理二/">Tue, Dec 29 2015, 10:41:19 pm</a></time>

  
    <h1 class="title"><a href="/2015/12/29/浅谈iOS中的内存管理二/">浅谈iOS中的内存管理(二)</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/iOS/">iOS</a>, <a href="/tags/内存管理/">内存管理</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <hr>
<p>紧接上一篇的内容，这里将会剖析 alloc/retain/release/dealloc/autorelease 的实现，我们采用<a href="http://gnustep.org" target="_blank" rel="external">GNUstep</a>。GNUstep是一套Cocoa框架的互换开源框架，当然和苹果自身的实现方式肯定有所区别，但思想大同小异，区别主要出于不同应用条件下的不同实现方式，哪一种更合适去达到某些需求。这非常类似于操作系统中各种同类算法、实现方式的采用，这将会在本篇文章中有所涉及。</p>
<p>但我个人经验还不足够，如有差错，恳请斧正，轻喷。</p>
<h2 id="2-1-1-下载GNUstep"><a href="#2-1-1-下载GNUstep" class="headerlink" title="2.1.1 下载GNUstep"></a>2.1.1 下载GNUstep</h2><p>这里我们主要用到的是<code>GNUstep Core</code>，分为<code>GNUstep Make</code> <code>GNUstep Base</code> <code>GNUstep GUI</code> 和<code>GNUstep Backend</code> 四部分。<br>这里我们只用到<a href="http://ftpmain.gnustep.org/pub/gnustep/core/gnustep-base-1.24.8.tar.gz" target="_blank" rel="external">GNUstep Base</a> 这里主要是Foundation框架的实现。</p>
<p><img src="http://7pulfv.com1.z0.glb.clouddn.com/GNUstepCatalog.png" alt=""></p>
<p>直接用Xcode打开目录下的<code>base.xcodeproj</code>文件 就可以查看工程目录结构了。初步看一下目录结构，然后我们就开始吧。</p>
<h2 id="2-1-2-命名规范"><a href="#2-1-2-命名规范" class="headerlink" title="2.1.2 命名规范"></a>2.1.2 命名规范</h2><p>根据Apple的命名规范，凡是以 <code>alloc</code>, <code>copy</code>, <code>mutableCopy</code> 和 <code>new</code>开头的方法都是返回自己生成的对象并持有，反之则不持有。</p>
<h2 id="2-1-3-从alloc开始"><a href="#2-1-3-从alloc开始" class="headerlink" title="2.1.3 从alloc开始"></a>2.1.3 从alloc开始</h2><p>首先看最最最常见的<code>NSObject</code>这个类(当然这个工程的文件实在太多了，与其一个一个找不如用<code>cmd+shift+o</code>然后输入文件名直接定位，当然也可以输入方法名，这些快捷键在此后会经常用到)。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>) alloc</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>alloc</code>方法会申请一个新的实例，方式是通过<code>allocWithZone</code>方法调用<code>NSDefaultMallocZone</code>分配对象空间，如下是源码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span> (<span class="keyword">self</span>, <span class="number">0</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把视线转移到<code>NSAllocateObject</code>这个方法，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">id</span> <span class="built_in">NSAllocateObject</span> (Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">id</span>  new;</div><div class="line">  <span class="keyword">int</span>  size;</div><div class="line"></div><div class="line">  <span class="built_in">NSCAssert</span>((!class_isMetaClass(aClass)), <span class="string">@"Bad class for new object"</span>);</div><div class="line">  size = class_getInstanceSize(aClass) + extraBytes + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout);</div><div class="line">  <span class="keyword">if</span> (zone == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      zone = <span class="built_in">NSDefaultMallocZone</span>();</div><div class="line">    &#125;</div><div class="line">  new = <span class="built_in">NSZoneMalloc</span>(zone, size);</div><div class="line">  <span class="keyword">if</span> (new != <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">      memset (new, <span class="number">0</span>, size);</div><div class="line">      new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</div><div class="line">      object_setClass(new, aClass);</div><div class="line">      AADD(aClass, new);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="number">0</span> == cxx_construct)</div><div class="line">    &#123;</div><div class="line">      cxx_construct = sel_registerName(<span class="string">".cxx_construct"</span>);</div><div class="line">      cxx_destruct = sel_registerName(<span class="string">".cxx_destruct"</span>);</div><div class="line">    &#125;</div><div class="line">  callCXXConstructors(aClass, new);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> new;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们来分析下这段代码，首先<code>size</code>变量用来计算容纳对象所需要的内存大小 其中有一个结构体<code>obj_layout</code>，如下是这个结构体的代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> obj_layout &#123;</div><div class="line">    <span class="keyword">char</span>  padding[__BIGGEST_ALIGNMENT__ - ((UNP % __BIGGEST_ALIGNMENT__)</div><div class="line">      ? (UNP % __BIGGEST_ALIGNMENT__) : __BIGGEST_ALIGNMENT__)];</div><div class="line">    <span class="built_in">NSUInteger</span>  retained;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span>  <span class="keyword">struct</span> obj_layout *obj;</div></pre></td></tr></table></figure>
<p><code>obj_layout</code>分两种，如上是一种，<code>obj_layout_unpadded</code>是另一种，后者去掉了<code>padding</code>这个变量。</p>
<p>其实<code>padding</code>是一个用于填充的变量，主要用于结构体的对齐，这里暂时先不讨论结构体对齐相关的内容。</p>
<p><code>obj_layout</code>中的<code>retained</code>用来保存引用计数，写入对象头部，在对象的内存块完成置零初始化后返回。</p>
<p>回到<code>NSAllocateObject</code>方法，此后的过程可以描述为：<code>NSAllocateObject</code>通过调用<code>NSZoneMalloc</code>来分配存放对象所需要的内存空间，之后将该内存空间置零，最后把<code>new</code>指针返回。</p>
<p>通过调用<code>retainCount</code>方法即可取得对象的引用计数，如下是其实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount</div><div class="line">&#123;</div><div class="line"><span class="meta">#if  GS_WITH_GC</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">UINT_MAX</span>;</div><div class="line"><span class="meta">#else</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能的返回值有两条，其中一条是一个MAX值，这主要用来方便的表示一个对象永远不会被<code>dealloc</code>，将视线转移到第二条值，如下是<code>NSExtraRefCount</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></div><div class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line"><span class="meta">#ifdef __OBJC_GC__</span></div><div class="line">  <span class="keyword">if</span> (objc_collecting_enabled())</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">UINT_MAX</span><span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"><span class="meta">#if  GS_WITH_GC</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">UINT_MAX</span> - <span class="number">1</span>;</div><div class="line"><span class="meta">#else</span></div><div class="line">  <span class="keyword">return</span> ((obj)anObject)[<span class="number">-1</span>].retained;</div><div class="line"><span class="meta">#endif </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个流程可以被描述为：<code>NSExtraRefCount</code>方法由对象寻址找到对象内存头，访问其中的<code>retained</code>变量。其中的+1/-1操作只是概念上的区别。</p>
<p>相信在这里你肯定和我一样很好奇，<code>NSDefaultMallocZone</code>和<code>NSZoneMalloc</code>的名字中包含的NSZone是什么呢？</p>
<p>查阅了资料后，总结如下：</p>
<p>NSZone是为了防止内存碎片化而引入的结构。对内存分配的区域进行分化管理，根据使用对象的目的、大小进行分配内存到不同的区域中，从而提高内存管理效率。</p>
<p>其实在苹果的文档<a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a>中关于此处有提及</p>
<blockquote>
<p>You cannot use memory zones. There is no need to use NSZone any more—they are ignored by the modern Objective-C runtime anyway.</p>
</blockquote>
<p>总结起来一句话：在现代运行时操作系统中因为其内存管理本身已经极具效率，所以就忽略了<code>memory zone</code>的概念，如果使用它 反而会引起内存效率降低。</p>
<p>这也许也是GNUstep和苹果实现方式的区别之一，深入的了解总是很有意思的，不是吗？</p>
<p>下面三点用于描述引用计数值的变化：</p>
<ul>
<li>调用<code>alloc</code>/<code>retain</code>方法后，引用计数值+1</li>
<li><code>release</code>后，引用计数-1</li>
<li>引用计数值为0时，调用<code>dealloc</code>方法废弃对象</li>
</ul>
<h2 id="2-1-5-retain-release-dealloc"><a href="#2-1-5-retain-release-dealloc" class="headerlink" title="2.1.5 retain/release/dealloc"></a>2.1.5 retain/release/dealloc</h2><h3 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h3><p>与<code>alloc</code>方法不同的是，<code>retain/release/dealloc</code>这三个方法我们关注的是实例方法，而不是此前<code>alloc</code>的类方法(想一想为什么?)。</p>
<p>但是这并不意味着这些方法不可以用作类方法，从源码中，我们可以看到<code>retain</code>方法就兼具类方法与实例方法，<code>retain</code>的类方法主要用于在NSArray这类容器中存储并持有对象。如下是<code>retain</code>的实例方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line"><span class="meta">#if  (GS_WITH_GC == 0)</span></div><div class="line">  <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);</div><div class="line"><span class="meta">#endif</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>忽略<code>GS_WITH_GC</code>整个讨厌的宏，默认的方式都是通过<code>NSIncrementExtraRefCount</code>实现。如下是<code>NSIncrementExtraRefCount</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span></div><div class="line"><span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject)</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#123;</div><div class="line"><span class="meta">#if  GS_WITH_GC || __OBJC_GC__</span></div><div class="line">  <span class="keyword">return</span>;</div><div class="line"><span class="meta">#else</span></div><div class="line">  <span class="keyword">if</span> (allocationLock != <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line"><span class="meta">#if  defined(GSATOMICREAD)</span></div><div class="line">      <span class="keyword">if</span> (GSAtomicIncrement((gsatomic_t)&amp;(((obj)anObject)[<span class="number">-1</span>].retained))</div><div class="line">        &gt; <span class="number">0xfffffe</span>)</div><div class="line">  &#123;</div><div class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></div><div class="line">      format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</div><div class="line">  &#125;</div><div class="line"><span class="meta">#else  </span></div><div class="line">      <span class="built_in">NSLock</span> *theLock = GSAllocationLockForObject(anObject);</div><div class="line"></div><div class="line">      [theLock lock];</div><div class="line">      <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    [theLock unlock];</div><div class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></div><div class="line">      format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</div><div class="line">  &#125;</div><div class="line">      ((obj)anObject)[<span class="number">-1</span>].retained++;</div><div class="line">      [theLock unlock];</div><div class="line"><span class="meta">#endif  </span></div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></div><div class="line">      format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</div><div class="line">  &#125;</div><div class="line">      ((obj)anObject)[<span class="number">-1</span>].retained++;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以描述为，在<code>retained</code>变量未超出其最大限定值时，retained++，否则抛异常。</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>如下是<code>release</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release</div><div class="line">&#123;</div><div class="line"><span class="meta">#if  (GS_WITH_GC == 0)</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</div><div class="line">    &#123;</div><div class="line"><span class="meta">#  ifdef OBJC_CAP_ARC</span></div><div class="line">      objc_delete_weak_refs(<span class="keyword">self</span>);</div><div class="line"><span class="meta">#  endif</span></div><div class="line">      [<span class="keyword">self</span> dealloc];</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个过程可以被描述为：当retained变量为正时-1，等于0时调用<code>dealloc</code>方法。</p>
<h3 id="dealloc"><a href="#dealloc" class="headerlink" title="dealloc"></a>dealloc</h3><p>如下是<code>dealloc</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) dealloc</div><div class="line">&#123;</div><div class="line">  <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span></div><div class="line"><span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">  Class aClass = object_getClass(anObject);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((anObject != <span class="literal">nil</span>) &amp;&amp; !class_isMetaClass(aClass))</div><div class="line">    &#123;</div><div class="line">      obj  o = &amp;((obj)anObject)[<span class="number">-1</span>];</div><div class="line">      <span class="built_in">NSZone</span>  *z = <span class="built_in">NSZoneFromPointer</span>(o);</div><div class="line">      (*finalize_imp)(anObject, finalize_sel);</div><div class="line">      AREM(aClass, (<span class="keyword">id</span>)anObject);</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">NSZombieEnabled</span> == <span class="literal">YES</span>)</div><div class="line">  &#123;</div><div class="line">    GSMakeZombie(anObject, aClass);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">NSDeallocateZombies</span> == <span class="literal">YES</span>)</div><div class="line">      &#123;</div><div class="line">        <span class="built_in">NSZoneFree</span>(z, o);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    object_setClass((<span class="keyword">id</span>)anObject, (Class)(<span class="keyword">void</span>*)<span class="number">0xdeadface</span>);</div><div class="line">    <span class="built_in">NSZoneFree</span>(z, o);</div><div class="line">  &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个过程可以被描述为：废弃由<code>alloc</code>申请的内存块。</p>
<h2 id="2-1-4-autorelease的原理与实现"><a href="#2-1-4-autorelease的原理与实现" class="headerlink" title="2.1.4 autorelease的原理与实现"></a>2.1.4 autorelease的原理与实现</h2><p>autorelease会在对象超出其生命周期时调用它的<code>-release</code>方法，使用方法如下：</p>
<ul>
<li>生成并持有<code>NSAutoreleasePool</code>对象</li>
<li>调用已分配对象的<code>-autorelease</code>方法</li>
<li>废弃<code>NSAutoreleasePool</code>对象</li>
</ul>
<p>一般由NSRunLoop实现对<code>NSAutoreleasePool</code>对象进行生成、持有和废弃的处理。</p>
<p>实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>) autorelease</div><div class="line">&#123;</div><div class="line"><span class="meta">#if  !GS_WITH_GC</span></div><div class="line">  <span class="keyword">if</span> (double_release_check_enabled)</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">NSUInteger</span> release_count;</div><div class="line">      <span class="built_in">NSUInteger</span> retain_count = [<span class="keyword">self</span> retainCount];</div><div class="line">      release_count = [autorelease_class autoreleaseCountForObject:<span class="keyword">self</span>];</div><div class="line">      <span class="keyword">if</span> (release_count &gt; retain_count)</div><div class="line">        [<span class="built_in">NSException</span></div><div class="line">    raise: <span class="built_in">NSGenericException</span></div><div class="line">    format: <span class="string">@"Autorelease would release object too many times.\n"</span></div><div class="line">    <span class="string">@"%"</span>PRIuPTR<span class="string">" release(s) versus %"</span>PRIuPTR<span class="string">" retain(s)"</span>,</div><div class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)release_count, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)retain_count];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  (*autorelease_imp)(autorelease_class, autorelease_sel, <span class="keyword">self</span>);</div><div class="line"><span class="meta">#endif</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的实现比较复杂，很多变量或指针的定义都在<code>initialize</code>方法中，实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>) initialize</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="built_in">NSObject</span> <span class="keyword">class</span>])</div><div class="line">    &#123;</div><div class="line"><span class="meta">#if  GS_WITH_GC</span></div><div class="line">      GC_init();</div><div class="line">      GC_set_warn_proc(GSGarbageCollectorLog);</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="meta">#ifdef __MINGW__</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">extern</span> <span class="keyword">void</span> gnustep_base_socket_init(<span class="keyword">void</span>);</div><div class="line">        gnustep_base_socket_init();</div><div class="line">      &#125;</div><div class="line"><span class="meta">#else /* __MINGW__ */</span></div><div class="line"></div><div class="line"><span class="meta">#ifdef  SIGPIPE</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If SIGPIPE is not handled or ignored, we will abort on any attempt</div><div class="line">     * to write to a pipe/socket that has been closed by the other end!</div><div class="line">     * We therefore need to ignore the signal if nothing else is already</div><div class="line">     * handling it.</div><div class="line">     */</div><div class="line"><span class="meta">#ifdef  HAVE_SIGACTION</span></div><div class="line">      &#123;</div><div class="line">  <span class="keyword">struct</span> sigaction  act;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (sigaction(SIGPIPE, <span class="number">0</span>, &amp;act) == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (act.sa_handler == SIG_DFL)</div><div class="line">        &#123;</div><div class="line">    <span class="comment">// Not ignored or handled ... so we ignore it.</span></div><div class="line">    act.sa_handler = SIG_IGN;</div><div class="line">    <span class="keyword">if</span> (sigaction(SIGPIPE, &amp;act, <span class="number">0</span>) != <span class="number">0</span>)</div><div class="line">      &#123;</div><div class="line">        fprintf(stderr, <span class="string">"Unable to ignore SIGPIPE\n"</span>);</div><div class="line">      &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      fprintf(stderr, <span class="string">"Unable to retrieve information about SIGPIPE\n"</span>);</div><div class="line">    &#125;</div><div class="line">      &#125;</div><div class="line"><span class="meta">#else /* HAVE_SIGACTION */</span></div><div class="line">      &#123;</div><div class="line">  <span class="keyword">void</span>  (*handler)(<span class="built_in">NSInteger</span>);</div><div class="line"></div><div class="line">  handler = signal(SIGPIPE, SIG_IGN);</div><div class="line">  <span class="keyword">if</span> (handler != SIG_DFL)</div><div class="line">    &#123;</div><div class="line">      signal(SIGPIPE, handler);</div><div class="line">    &#125;</div><div class="line">      &#125;</div><div class="line"><span class="meta">#endif /* HAVE_SIGACTION */</span></div><div class="line"><span class="meta">#endif /* SIGPIPE */</span></div><div class="line"><span class="meta">#endif /* __MINGW__ */</span></div><div class="line"></div><div class="line">      finalize_sel = <span class="keyword">@selector</span>(finalize);</div><div class="line">      finalize_imp = class_getMethodImplementation(<span class="keyword">self</span>, finalize_sel);</div><div class="line"></div><div class="line"><span class="meta">#if defined(__FreeBSD__) &amp;&amp; defined(__i386__)</span></div><div class="line">      <span class="comment">// Manipulate the FPU to add the exception mask. (Fixes SIGFPE</span></div><div class="line">      <span class="comment">// problems on *BSD)</span></div><div class="line">      <span class="comment">// Note this only works on x86</span></div><div class="line"><span class="meta">#  if defined(FE_INVALID)</span></div><div class="line">      fedisableexcept(FE_INVALID);</div><div class="line"><span class="meta">#  else</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">short</span> cw;</div><div class="line"></div><div class="line">        __asm__ <span class="keyword">volatile</span> (<span class="string">"fstcw (%0)"</span> : : <span class="string">"g"</span> (&amp;cw));</div><div class="line">        cw |= <span class="number">1</span>; <span class="comment">/* Mask 'invalid' exception */</span></div><div class="line">        __asm__ <span class="keyword">volatile</span> (<span class="string">"fldcw (%0)"</span> : : <span class="string">"g"</span> (&amp;cw));</div><div class="line">      &#125;</div><div class="line"><span class="meta">#  endif</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">      <span class="comment">/* Create the global lock.</span></div><div class="line">       * NB. Ths is one of the first things we do ... setting up a new lock</div><div class="line">       * must not call any other Objective-C classes and must not involve</div><div class="line">       * any use of the autorelease system.</div><div class="line">       */</div><div class="line">      gnustep_global_lock = [<span class="built_in">NSRecursiveLock</span> new];</div><div class="line"></div><div class="line">      <span class="comment">/* Behavior debugging ... enable with environment variable if needed.</span></div><div class="line">       */</div><div class="line">      GSObjCBehaviorDebug(GSPrivateEnvironmentFlag(<span class="string">"GNUSTEP_BEHAVIOR_DEBUG"</span>,</div><div class="line">  GSObjCBehaviorDebug(<span class="number">-1</span>)));</div><div class="line"></div><div class="line">      <span class="comment">/* See if we should cleanup at process exit.</span></div><div class="line">       */</div><div class="line">      <span class="keyword">if</span> (<span class="literal">YES</span> == GSPrivateEnvironmentFlag(<span class="string">"GNUSTEP_SHOULD_CLEAN_UP"</span>, <span class="literal">NO</span>))</div><div class="line">  &#123;</div><div class="line">    [<span class="keyword">self</span> setShouldCleanUp: <span class="literal">YES</span>];</div><div class="line">    [<span class="keyword">self</span> registerAtExit: <span class="keyword">@selector</span>(_atExit)];</div><div class="line">  &#125;</div><div class="line">      autorelease_class = [<span class="built_in">NSAutoreleasePool</span> <span class="keyword">class</span>];</div><div class="line">      autorelease_sel = <span class="keyword">@selector</span>(addObject:);</div><div class="line">      autorelease_imp = [autorelease_class methodForSelector: autorelease_sel];</div><div class="line"></div><div class="line">      <span class="built_in">NSConstantStringClass</span> = [<span class="built_in">NSString</span> constantStringClass];</div><div class="line"></div><div class="line">      GSPrivateBuildStrings();</div><div class="line">      <span class="built_in">NSZombieEnabled</span> = GSPrivateEnvironmentFlag(<span class="string">"NSZombieEnabled"</span>, <span class="literal">NO</span>);</div><div class="line">      <span class="built_in">NSDeallocateZombies</span> = GSPrivateEnvironmentFlag(<span class="string">"NSDeallocateZombies"</span>, <span class="literal">NO</span>);</div><div class="line">      zombieMap = <span class="built_in">NSCreateMapTable</span>(<span class="built_in">NSNonOwnedPointerMapKeyCallBacks</span>,</div><div class="line">  <span class="built_in">NSNonOwnedPointerMapValueCallBacks</span>, <span class="number">0</span>);</div><div class="line">      zombieClass = objc_lookUpClass(<span class="string">"NSZombie"</span>);</div><div class="line"></div><div class="line">      <span class="comment">/* Now that we have a working autorelease system and working string</span></div><div class="line">       * classes we are able to set up notifications.</div><div class="line">       */</div><div class="line">      [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</div><div class="line">  addObserver: <span class="keyword">self</span></div><div class="line">     selector: <span class="keyword">@selector</span>(_becomeMultiThreaded:)</div><div class="line">         name: <span class="built_in">NSWillBecomeMultiThreadedNotification</span></div><div class="line">       object: <span class="literal">nil</span>];</div><div class="line">      [<span class="built_in">NSUserDefaults</span> <span class="keyword">class</span>];</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查了一些资料，解释一下这么做的目的，这里用到了一种叫做<code>IMP Caching</code>的技术用于解决对<code>autorelease</code>方法的频繁的调用，这个方法非常高效，在进行调用时，对类名、方法名和运行时的函数指针的结果进行缓存，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">autorelease_class = [<span class="built_in">NSAutoreleasePool</span> <span class="keyword">class</span>];</div><div class="line">autorelease_sel = <span class="keyword">@selector</span>(addObject:);</div><div class="line">autorelease_imp = [autorelease_class methodForSelector: autorelease_sel];</div></pre></td></tr></table></figure>
<p>还记得<code>autorelease</code>方法实现中的<code>(*autorelease_imp)(autorelease_class, autorelease_sel, self);</code>这一句吗？ 这就是用来调用其缓存值。据说这相比于直接调用会快两倍左右(未考证)。</p>
<p>总结一句话：本质就是调用<code>NSAutoreleasePool</code>中的<code>+addObject</code>方法来向缓存池中添加对象。</p>
<p>那让我们转移到<code>NSAutoreleasePool</code>类。</p>
<p>如下是<code>addObject</code>方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>) addObject: (<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">  <span class="comment">/* If the global, static variable AUTORELEASE_ENABLED is not set,</span></div><div class="line">     do nothing, just return. */</div><div class="line">  <span class="keyword">if</span> (!autorelease_enabled)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (_released_count &gt;= pool_count_warning_threshhold)</div><div class="line">    [<span class="built_in">NSException</span> raise: <span class="built_in">NSGenericException</span></div><div class="line">     format: <span class="string">@"AutoreleasePool count threshhold exceeded."</span>];</div><div class="line"></div><div class="line">  <span class="comment">/* Get a new array for the list, if the current one is full. */</span></div><div class="line">  <span class="keyword">while</span> (_released-&gt;count == _released-&gt;size)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (_released-&gt;next)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">/* There is an already-allocated one in the chain; use it. */</span></div><div class="line">    _released = _released-&gt;next;</div><div class="line">  &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">/* We are at the end of the chain, and need to allocate a new one. */</span></div><div class="line">    <span class="keyword">struct</span> autorelease_array_list *new_released;</div><div class="line">    <span class="keyword">unsigned</span> new_size = _released-&gt;size * <span class="number">2</span>;</div><div class="line">  </div><div class="line">    new_released = (<span class="keyword">struct</span> autorelease_array_list*)</div><div class="line">      <span class="built_in">NSZoneMalloc</span>(<span class="built_in">NSDefaultMallocZone</span>(),</div><div class="line">      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> autorelease_array_list) + (new_size * <span class="keyword">sizeof</span>(<span class="keyword">id</span>)));</div><div class="line">    new_released-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    new_released-&gt;size = new_size;</div><div class="line">    new_released-&gt;count = <span class="number">0</span>;</div><div class="line">    _released-&gt;next = new_released;</div><div class="line">    _released = new_released;</div><div class="line">  &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Put the object at the end of the list. */</span></div><div class="line">  _released-&gt;objects[_released-&gt;count] = anObj;</div><div class="line">  (_released-&gt;count)++;</div><div class="line"></div><div class="line">  <span class="comment">/* Keep track of the total number of objects autoreleased in this pool */</span></div><div class="line">  _released_count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>) addObject: (<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">  <span class="built_in">NSThread</span>    *t = GSCurrentThread();</div><div class="line">  <span class="built_in">NSAutoreleasePool</span>  *pool;</div><div class="line">  <span class="built_in">NSAssert</span>(<span class="literal">nil</span> != t, <span class="string">@"Creating autorelease pool on nonexistent thread!"</span>);</div><div class="line"></div><div class="line">  pool = t-&gt;_autorelease_vars.current_pool;</div><div class="line">  <span class="keyword">if</span> (pool == <span class="literal">nil</span> &amp;&amp; t-&gt;_active == <span class="literal">NO</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">// Don't leak while exiting thread.</span></div><div class="line">      pool = t-&gt;_autorelease_vars.current_pool = [<span class="keyword">self</span> new];</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">if</span> (pool != <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">      (*pool-&gt;_addImp)(pool, <span class="keyword">@selector</span>(addObject:), anObj);</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="built_in">NSAutoreleasePool</span>  *arp = [<span class="built_in">NSAutoreleasePool</span> new];</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (anObj != <span class="literal">nil</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"autorelease called without pool for object (%p) "</span></div><div class="line">      <span class="string">@"of class %@ in thread %@"</span>, anObj,</div><div class="line">      <span class="built_in">NSStringFromClass</span>([anObj <span class="keyword">class</span>]), [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">  &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"autorelease called without pool for nil object."</span>);</div><div class="line">  &#125;</div><div class="line">      [arp drain];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现的比较复杂，简单的描述下：addObject类方法调用正在使用的<code>NSAutoreleasePool</code>对象的<code>addObject</code>实例方法，以实现缓存。其中还包括了关于嵌套生成或持有<code>NSAutoreleasePool</code>对象的情况，在这种情况下，使用嵌套最内侧的对象。<code>NSAutoreleasePool</code>的<code>addObject</code>方法和<code>NSMutableArray</code>的<code>addObject</code>方法类似，使用的是链表。</p>
<p><strong>注意：</strong> OC中的Array其实和其他语言中的数组有所区别，<code>NSArray</code>是数组，而且不可变，但是<code>NSMutableArray</code>的实现非常类似于链表，可以很方便地、在任意一个位置添加或移除一个节点。</p>
<p><code>drain</code>操作类似<code>release</code>操作，只不过<code>drain</code>用于<code>NSAutoreleasePool</code>对象的释放。</p>
<p>系统在runloop中创建的autoreleaspool会在 runloop 一个事件结束时进行释放操作，我们手动创建的 autoreleasepool 会在 block 执行完成之后进行 drain 操作。</p>
<p><strong>注意：</strong></p>
<ul>
<li>当 block 以异常（exception）结束时，pool 不会被 drain</li>
<li>Pool 的 drain 操作会把所有标记为 autorelease 的对象的引用计数减一，但是并不意味着这个对象一定会被释放掉，我们可以在 autorelease pool 中手动 retain 对象，以延长它的生命周期（在 MRC 中）。</li>
</ul>
<p>需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。</p>
<p>因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。有一个普遍的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span>* string = <span class="string">@"ab c"</span>;</div><div class="line">        <span class="built_in">NSArray</span>* array = [string componentsSeparatedByString:string];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不使用 autoreleasepool ，需要在循环结束之后释放 100000000 个字符串，如果 使用的话，则会在每次循环结束的时候都进行 release 操作。</p>
<p>下一篇，我们将正式步入ARC。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/12/29/浅谈iOS中的内存管理二/#more" class="more-link"><i class="fa fa-chevron-right"></i>查看全文</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://iJack.pw/2015/12/29/浅谈iOS中的内存管理二/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/12/29/浅谈iOS中的内存管理二/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-12-30T01:50:38.000Z"><a href="/2015/12/29/浅谈iOS中的内存管理一/">Tue, Dec 29 2015, 8:50:38 pm</a></time>

  
    <h1 class="title"><a href="/2015/12/29/浅谈iOS中的内存管理一/">浅谈iOS中的内存管理(一)</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/iOS/">iOS</a>, <a href="/tags/内存管理/">内存管理</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <hr>
<p>本系列文章主要目的是我个人对iOS中内存管理的一些见解与思考，参考了一部分资料，时间有限，此处就不一一列出了，主要参考为GNUStep、OC的Runtime、苹果的官方文档、以及KS&amp;TF等大牛的博客。</p>
<p>上古时代，iOS的程序还是手工管理内存的。大概在iOS5后 OC采用了ARC机制，让编译器来进行内存管理，降低memory leak 和 crash的风险，极大的解放了程序员。</p>
<p>在讲述ARC前，先用MRC讲一下引用计数的原理，然后再看看ARC下，编译器帮我们做了什么。</p>
<h3 id="1-引用计数的原理"><a href="#1-引用计数的原理" class="headerlink" title="1.引用计数的原理"></a>1.引用计数的原理</h3><p>这里将OC中的对象操作以及其在OC中对应的方法分成四个类别，在这四个类别基础上产生了四个黄金法则，如下将一一介绍。</p>
<h3 id="1-1-对象操作的四个类别"><a href="#1-1-对象操作的四个类别" class="headerlink" title="1.1 对象操作的四个类别"></a>1.1 对象操作的四个类别</h3><table>
<thead>
<tr>
<th>对象操作</th>
<th style="text-align:center">OC中对应的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td style="text-align:center">alloc/new/copy/mutableCopy等</td>
</tr>
<tr>
<td>持有对象</td>
<td style="text-align:center">retain</td>
</tr>
<tr>
<td>释放对象</td>
<td style="text-align:center">release</td>
</tr>
<tr>
<td>废弃对象</td>
<td style="text-align:center">dealloc</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong>这些对象操作的方法其实并不包括在OC中，而是包含在Cocoa框架下的Foundation框架中。</p>
<h3 id="1-2-四个黄金法则"><a href="#1-2-四个黄金法则" class="headerlink" title="1.2 四个黄金法则"></a>1.2 四个黄金法则</h3><ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不在需要自己持有的对象的时候，释放。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<p>如下是四个黄金法则对应的代码示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 自己生成并持有该对象</div><div class="line"> */</div><div class="line"> <span class="keyword">id</span> obj0 = [[<span class="built_in">NSObeject</span> alloc] init];</div><div class="line"> <span class="keyword">id</span> obj1 = [<span class="built_in">NSObeject</span> new];</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 持有非自己生成的对象</div><div class="line"> */</div><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSArray</span> array]; <span class="comment">// 非自己生成的对象，且该对象存在，但自己不持有</span></div><div class="line">[obj <span class="keyword">retain</span>]; <span class="comment">// 自己持有对象</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 不在需要自己持有的对象的时候，释放</div><div class="line"> */</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObeject</span> alloc] init]; <span class="comment">// 此时持有对象</span></div><div class="line">[obj release]; <span class="comment">// 释放对象</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 指向对象的指针仍就被保留在obj这个变量中</div><div class="line"> * 但对象已经释放，不可访问</div><div class="line"> */</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 非自己持有的对象无法释放</div><div class="line"> */</div><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSArray</span> array]; <span class="comment">// 非自己生成的对象，且该对象存在，但自己不持有</span></div><div class="line">[obj release]; <span class="comment">// 此时将运行时crash 或编译器报error</span></div></pre></td></tr></table></figure>
<p>此时，我相信你跟我一样，一定很好奇，类似 <code>[NSArray array]</code>这个方法实现的<strong>非自己生成的对象，且该对象存在，但自己不持有</strong> 这个特性是怎么实现的？</p>
<p>其实这里使用的是一个<code>autorelease</code>方法，这里我来构造一个建议的方法来实现这个思想，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>) getAObjNotRetain &#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]; <span class="comment">// 自己持有对象</span></div><div class="line">    [obj autorelease]; <span class="comment">// 取得的对象存在，但自己不持有该对象</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>autorelease</code> 使得对象在超出生命周期后能正确的被释放(通过调用release方法)。</p>
<p>那<code>autorelease</code>和<code>release</code>有什么区别呢？ 此后会剖析其具体实现方式，这里仅进行简单说明：</p>
<p>在调用<code>release</code>后，对象会被立即释放，而调用<code>autorelease</code>后，对象不会被立即释放，而是注册到<code>autoreleasepool</code>中，经过一段时间后pool结束，此时调用<code>release</code>方法，对象被释放。</p>
<p><strong>注意：</strong> autorelease绝不等同于Java中的垃圾收集器，此后分析实现代码后便会了解具体原因。</p>
<p>下一篇文章将会讲解关于 alloc/retain/release/dealloc 的实现 以方便了解最终的ARC的实现。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/12/29/浅谈iOS中的内存管理一/#more" class="more-link"><i class="fa fa-chevron-right"></i>查看全文</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://iJack.pw/2015/12/29/浅谈iOS中的内存管理一/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/12/29/浅谈iOS中的内存管理一/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-12-29T04:06:41.000Z"><a href="/2015/12/28/关于iOS9的APP瘦身/">Mon, Dec 28 2015, 11:06:41 pm</a></time>

  
    <h1 class="title"><a href="/2015/12/28/关于iOS9的APP瘦身/">关于iOS9的APP瘦身</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/iOS/">iOS</a>, <a href="/tags/翻译/">翻译</a>, <a href="/tags/iOS9/">iOS9</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <hr>
<blockquote>
<p>本文翻译自Gregg Mojica发布在<a href="http://www.appcoda.com/" target="_blank" rel="external">AppCode</a>上的文章<a href="http://www.appcoda.com/app-thinning/" target="_blank" rel="external">Working with App Thinning in iOS 9</a>，文章版权由AppCoda授给SwiftGG翻译组。翻译者为博主<a href="http://iJack.pw">JackAlan</a></p>
</blockquote>
<p>iOS9仅在推出后的几周后，在iOS设备上的安装量就超过了一半。这使它获得有史以来最快的普及率，超过了iOS7在2013年的记录。</p>
<p>在此教程中，我们将探索为什么App瘦身是重要的以及如何在自己的App中利用这个令人兴奋的新特性。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/app-thinning-1024x682.png" alt=""></p>
<p>在本次WWDC中开放的APP瘦身是一个令人兴奋的新技术，将会改变整个下载的过程。就用户说流量消耗大，iOS设备内存限制以及更快速的下载而言，App瘦身是一个值得学习的至关重要的特性。</p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>对于这篇教程，假定你有Xcode的工作知识，以及如何驾驭IDE。如果这对你来说很陌生，或者你根本不确定IDE是什么，你或许应该在看一下<a href="http://www.appcoda.com/ios-programming-course/" target="_blank" rel="external">excellent free course</a>.</p>
<p>我也假定你已经理解如何去在AppStore上或者TestFlight(苹果beta版App测试服务)上发布App。我不会具体到讲述如何用TestFlight.</p>
<p>让我们开始吧。</p>
<h2 id="App瘦身简介"><a href="#App瘦身简介" class="headerlink" title="App瘦身简介"></a>App瘦身简介</h2><p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/apple_app_slicing_illustration-516x300.jpg" alt=""></p>
<p>因为当前市场上有着大量的iOS设备，以及多种屏幕尺寸和分辨率，让一个App在多种屏幕下看起来非常棒需要大量的资源(比如png, jpeg以及二进制的PDF)。不幸的是，这导致用户需要下载一个巨大的程序包(此前版本的iOS强制用户下载全部App文件，包括他们在用iPhone时永远也不会用到的适配iPad的图片)。16G的iPhone仍然是一个非常实际的存在(并且可能短时间内不会消失)，所以你要让App缩小体积并且可快速下载以保证用户有足够的空间并优化整体体验。App瘦身特性让这成为可能。</p>
<p>现今，App不仅仅由代码和图片组成。当今的App不仅包括可执行代码而且还有32位，64位版本(优化各种架构比如arm64，arm7S和arm7)，3D图形技术(例如OpenGL，Metal等)，声音，其他文件。总之，当下App的水准到达了令人难以置信的复杂程度。这就是App瘦身需要拯救的地方。</p>
<p>App瘦身会自动检测用户设备类型(比如型号名称)，并只为特定的设备下载相关内容。换句话来说，如果你使用iPad Mini 1(没有视网膜屏而是1X的分辨率)，然后只有1X的文件会被下载(仅在这此时)。更强大的清晰的资源(比如iPad Mini 3或4中的)将不提供下载。因为用户只需要下载他/她的特定设备的内容，这加速了下载过程，并节省了设备上的空间。</p>
<p>虽然这起初可能听起来很复杂，我们将深入到具体的细节。Xcode和App Store处理这项工作的绝大部分。因此，本教程中不会有太多的代码，而是重点关注理解App瘦身的过程和技术使它成为现实。</p>
<p>App瘦身有三个主要方面，应用程序切片(<code>App Slicing</code>) 中间代码(<code>Bitcode</code>)和按需加载资源(<code>On Demand Resources</code>)。在本教程中，我们将一一探索。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/13196-7761-150609-Developer-2-l-545x300.jpg" alt=""></p>
<h2 id="应用程序切片-App-Slicing"><a href="#应用程序切片-App-Slicing" class="headerlink" title="应用程序切片(App Slicing)"></a>应用程序切片(App Slicing)</h2><p>App瘦身第一个我们要讨论的就是切片(slicing)。根据苹果的文档，</p>
<blockquote>
<p>切片是创建和提供不同的目标设备的应用程序包的变体(<code>variant</code>)的过程。 一个变体(<code>variant</code>)只包含可执行架构和目标设备所需要的资源。</p>
</blockquote>
<p>换句话来说，应用程序切片只提供给与每个设备相关的资源(取决于屏幕分辨率和架构等等)。事实上，应用程序切片处理了App瘦身进程的绝大多数。</p>
<p>当你已经准备好提交App时，和此前一样，你上传了 .IPA 或者 .App文件到iTunes Connect(但是必须使用Xcode7因为它包含支持App瘦身的iOS9 SDK). 然后App Store将App进行切片，创建特定的变体(<code>variant</code>)，这些变体将被分发给每个设备，依据它的功能(<code>capabilities</code>).</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/slicing.png" alt=""></p>
<h2 id="按需加载资源-On-Demand-Resources"><a href="#按需加载资源-On-Demand-Resources" class="headerlink" title="按需加载资源(On Demand Resources)"></a>按需加载资源(On Demand Resources)</h2><p>为了完全理解App瘦身，很有必要去了解 按需加载资源(<code>ODR</code>). 按需所加载的资源就是在App初次安装后可以被下载的文件。例如，特定关卡的游戏(和这些关卡相关的内容) 只有在玩家解锁它们的时候才可以被下载。此外，在设定的时间内，玩家没有进行的早期的关卡可以被移除，以节省设备的存储空间。</p>
<p>在Xcode的设置中(在Build Setting下)，开启按需加载资源需要更改”Enable On Demand Resources” 这个布尔值为”YES”.</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-3.53.20-PM.png" alt=""></p>
<h2 id="中间代码-Bitcode"><a href="#中间代码-Bitcode" class="headerlink" title="中间代码(Bitcode)"></a>中间代码(Bitcode)</h2><p>App瘦身的最后一个也是第三个方面就是中间代码。中间代码有点抽象，但在本质上，它是在App被下载前，苹果优化它的新途径。中间代码使得App可以在任何设备上运行的尽可能的快速和高效。中间代码可以为最近的编译器自动编译App，并且对特定的架构做优化。(例如 arm64 64位处理器 如iPhone6s和iPad Air 2)</p>
<p>中间代码使得下载变得更小，通过排除被用于不同架构的优化而非仅仅下载相关的优化。</p>
<p>对于iOS，中间代码是一种新的特性，并且对于新的工程来说它需要被手动开启。这个过程可以被完成通过在Build Setting下的工程设置并且选择Enable bitcode为YES.</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-3.50.06-PM.png" alt=""></p>
<h2 id="在你的项目进行App瘦身"><a href="#在你的项目进行App瘦身" class="headerlink" title="在你的项目进行App瘦身"></a>在你的项目进行App瘦身</h2><p>尽管Xcode和App Store 处理了App瘦身的绝大多数流程，你仍然需要采取一定的预防措施以确保你的App使用了这种新的技术。首要的，你必须使用资源目录(<code>asset catalogs</code>).在这一点上，大多数的App默认使用资源目录(<code>asset catalogs</code>).如果你还没有用采用资源目录(<code>asset catalogs</code>)，你现有的大部分内容可以被转移到一个目录下通过按下在Xcode的项目设置下的”Use Asset Catalog”按钮，如下所示。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-7.59.13-PM1.png" alt=""></p>
<p>Xcode的新特性之一就是<code>Sprite Atlases</code>. Sprite Atlases基本上是资源目录和SpriteKit的组合(Xcode创建2D游戏的技术)。同样的，如果你是用SpriteKit，App瘦身那是必须的。</p>
<h2 id="测试App瘦身"><a href="#测试App瘦身" class="headerlink" title="测试App瘦身"></a>测试App瘦身</h2><p>正如你在如上的组图中看到的，Xcode和苹果的App Store处理了绝大多数App瘦身的过程，这使得在你自己的App中采用这个技术变得相对容易。但是如果你想测试你的App并且确保它已经应用了App瘦身呢？幸运的是苹果的TestFlight提供了完美的解决方案。除App Store的应用瘦身技术外，TestFlight的用户也可以体验这个新特性。</p>
<p>在本篇教程的第二部分，我们将会探索如何在TestFlight中使用App瘦身。</p>
<p>首先，下载这个<a href="https://github.com/AlanMelody/AppThinning" target="_blank" rel="external">基本空白的项目</a>，解压，并且在Xcode中运行，你将会注意到这个项目基本没有什么除了在资源目录(<code>asset catalogs</code>)中的一系列的图片(以及少量的代码)。这个资源目录(<code>asset catalogs</code>) 也包含 1x, 2x 和 3x版本的app图标。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-9.00.47-PM-1024x239.png" alt=""></p>
<p>首先，在模拟器或者真机上运行这个App. 打开设置应用，点击<code>存储空间和iCloud使用</code>这一项(或者是<code>存储空间</code>这一项在非iOS9的设备上) 并且选择管理存储空间.向下滑动到我们刚刚编译好的App并且点击它。你想会注意到它大概有17.0MB的大小(这个大小可能略有不同，当上传至iTunes Connect时)。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/IMG_0106-2.png" alt=""></p>
<p>当你使用Xcode构建并运行一个App时，Xcode并不会自动的处理App变体(<code>variant</code>)和App瘦身。这样，整个App的文件都在你的设备上。</p>
<p>下一步，从Xcode中单击<code>Product</code>标签，并且选择<code>Archive</code>.</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-8.36.26-PM-1024x345.png" alt=""></p>
<blockquote>
<p>注意，你可能首先需要修改这个App的<code>Bundle Identifier</code>以匹配一个你自己创建的标识符。否则，这个App将不会被上传到iTunes Connect.</p>
</blockquote>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/appthinnning-1024x390.png" alt=""></p>
<p>确保你在点击”Submit”前，选择了”Include bitcode”。如果一切顺利的话，你将会看到一个绿色对号通知你这次构建已经被上传。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/iTunes-Connect-App-Thinning-1024x483.png" alt=""></p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Untitled.png" alt=""></p>
<p>安装后注意到这个App现在接近5.4MB. 这就是App瘦身的意义。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/IMG_0108.png" alt=""></p>
<p>哇哦！你刚刚从你的App中剔除掉了12.4MB - 并且这是一个非常基础的App. 那些包含多种不同的资源(<code>asset</code>)的App将会在App大小方面看到更急剧的变化喔~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇教程，我们看了看App瘦身的强大。如此一来，我们讨论了App瘦身的三个主要的方面：应用程序切片(<code>App Slicing</code>) 中间代码(<code>Bitcode</code>)和按需加载资源(<code>On Demand Resources</code>).</p>
<p>十月份的时候苹果当时说，iOS9.0和9.0.1 不会支持App切片，原因是由于一个问题影响iCloud创建自iOS9的备份，其中一些AppStore中的App将会只还原到同样型号的iOS设备。</p>
<p>不过现在都9.2啦，没有这个鬼畜的问题了。</p>
<p>总之，App瘦身特性将会加速App的下载和App的空间占用~</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/12/28/关于iOS9的APP瘦身/#more" class="more-link"><i class="fa fa-chevron-right"></i>查看全文</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://iJack.pw/2015/12/28/关于iOS9的APP瘦身/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/12/28/关于iOS9的APP瘦身/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-12-29T03:58:39.000Z"><a href="/2015/12/28/使用闭包初始化来加速 Swift 的 Playground/">Mon, Dec 28 2015, 10:58:39 pm</a></time>

  
    <h1 class="title"><a href="/2015/12/28/使用闭包初始化来加速 Swift 的 Playground/">用闭包初始化来加速Playground</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/iOS/">iOS</a>, <a href="/tags/Swift/">Swift</a>, <a href="/tags/翻译/">翻译</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <hr>
<blockquote>
<p>本文翻译自<a href="http://ericasadun.com/" target="_blank" rel="external">Erica Sadun</a>的文章<a href="http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/" target="_blank" rel="external">Speeding up Swift playgrounds with closure initialization</a>，文章版权由Erica Sadun授给SwiftGG翻译组。翻译者为博主<a href="http://iJack.pw">JackAlan</a></p>
</blockquote>
<p>Swift的Playground可能会莫名其妙地变慢，尤其当你使用 SpriteKit 或 SceneKit的时候。所以尽可能的把代码迁移到外部资源文件中，那样可以优化编译并获得更好的运行时速度。</p>
<p>这种方法的最大问题在于，你会因此失去在 Playground 中的线性流 linear flow。模块编译不支持修改变量的顶层指令。比如，你有类似如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">let</span> lightNode = <span class="type">SCNNode</span>()</div><div class="line">lightNode.light = <span class="type">SCNLight</span>()</div><div class="line">lightNode.light!.type = <span class="type">SCNLightTypeOmni</span></div><div class="line">lightNode.position = <span class="type">SCNVector3</span>(x: <span class="number">0</span>, y: <span class="number">10</span>, z: <span class="number">10</span>)</div><div class="line">scnscene.rootNode.addChildNode(lightNode)</div></pre></td></tr></table></figure>
<p>(这是苹果的示例代码，至于为什么去使用强制解包，不知道。。。)</p>
<p>不能将这些行直接移到一个模块文件中，因为你使用的是顶级调用，这将不会在一个外部Swift文件中编译。</p>
<p>你可以把这些写在一个函数中作为一种替代方法，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">setupLightNode</span><span class="params">()</span></span> -&gt; <span class="type">SCNNode</span> &#123;</div><div class="line"><span class="keyword">let</span> theLight = <span class="type">SCNNode</span>()</div><div class="line">theLight.light = <span class="type">SCNLight</span>()</div><div class="line">theLight.light!.type = <span class="type">SCNLightTypeOmni</span></div><div class="line">theLight.position = <span class="type">SCNVector3</span>(x: <span class="number">0</span>, y: <span class="number">10</span>, z: <span class="number">10</span>)</div><div class="line">scnscene.rootNode.addChildNode(theLight)</div><div class="line"><span class="keyword">return</span> theLight</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在声明处调用该函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> lightNode = setupLightNode()</div></pre></td></tr></table></figure>
<p>这简直挫爆了，这种方式创建了一个不必要的额外函数，而且它强制让你在一个新的实例被声明前去处理这个实例。</p>
<p>闭包提供了一种更吸引人、相对轻量的解决方案。正如下面你将看到的样例。在这里，将初始化的代码打包在一个单独的组中，执行并最终返回完全初始化的实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create and add a light to the scene</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">let</span> lightNode: <span class="type">SCNNode</span> = &#123;</div><div class="line">  <span class="keyword">let</span> theLight = <span class="type">SCNNode</span>()</div><div class="line">  theLight.light = <span class="type">SCNLight</span>()</div><div class="line">  theLight.light!.type = <span class="type">SCNLightTypeOmni</span></div><div class="line">  theLight.position = <span class="type">SCNVector3</span>(x: <span class="number">0</span>, y: <span class="number">10</span>, z: <span class="number">10</span>)</div><div class="line">  scnscene.rootNode.addChildNode(theLight)</div><div class="line">  <span class="keyword">return</span> theLight</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>这种方法使你可以使用单独的语句来创建和初始化一个对象，保留Playground中的便捷性和可读性，而且运行的会更快一点。</p>
<p><strong>更新</strong>：如下是另外一种用来建立类的实例的方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> •-&gt; &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// prepare class instance</span></div><div class="line"><span class="function"><span class="keyword">func</span> •-&gt; &lt;T&gt;<span class="params">(object: T, f: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">T</span> &#123;</div><div class="line">  f(object)</div><div class="line">  <span class="keyword">return</span> object</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;<span class="keyword">var</span> (x, y, z) = (<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>)&#125;</div><div class="line"><span class="keyword">let</span> myInstance = <span class="type">MyClass</span>() •-&gt; &#123;</div><div class="line"> $<span class="number">0</span>.x = <span class="string">"NewX"</span></div><div class="line"> $<span class="number">0</span>.y = <span class="string">"NewY"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>赶脚咋样？</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/12/28/使用闭包初始化来加速 Swift 的 Playground/#more" class="more-link"><i class="fa fa-chevron-right"></i>查看全文</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://iJack.pw/2015/12/28/使用闭包初始化来加速 Swift 的 Playground/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/12/28/使用闭包初始化来加速 Swift 的 Playground/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-12-29T03:58:39.000Z"><a href="/2015/12/28/CocoaPod的小技巧/">Mon, Dec 28 2015, 10:58:39 pm</a></time>

  
    <h1 class="title"><a href="/2015/12/28/CocoaPod的小技巧/">CocoaPod的小技巧</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/iOS/">iOS</a>, <a href="/tags/翻译/">翻译</a>, <a href="/tags/CocoaPod/">CocoaPod</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <hr>
<blockquote>
<p>本文翻译自Natasha The Robot发布在<a href="https://www.natashatherobot.com" target="_blank" rel="external">natashatherobot</a>的文章<a href="https://www.natashatherobot.com/cocoapods-on-a-team/" target="_blank" rel="external">The Trick to Working with CocoaPods on a Team</a>，文章版权由Natasha The Robot授给SwiftGG翻译组。翻译者为博主<a href="http://iJack.pw">JackAlan</a>。</p>
</blockquote>
<p>团队成员拥有不同的<code>cocoapods gem</code>安装版本，并且当有人运行<code>pod install</code>时，会把事情搞得一团糟。</p>
<p>最终不得不委托一人安装CocoaPods，并且把工程推到Github上以供我们使用。这显然非常挫。。。</p>
<p>跟<a href="https://twitter.com/NeoNacho" target="_blank" rel="external">@NeoNacho</a>提到了这个问题，他是CocoaPods的核心贡献者，并且他提供了解决方案。使用<code>Gemfile</code>！</p>
<p>你可以在<code>Gemfile</code>中指定<code>cocoapods gem</code>的使用版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">source &apos;https://ruby.taobao.org&apos;</div><div class="line"></div><div class="line">gem &apos;cocoapods&apos;, &apos;0.39.0&apos;</div></pre></td></tr></table></figure>
<p>当你更新了<code>Gemfile</code>文件以自动安装了正确版本的<code>gem</code>后，确保团队的每个成员都使用<code>bundle install</code>这条命令一次(仅仅一次)。</p>
<p>此后，只需要运行<code>bundle exec pod install</code>这条命令来安装新的<code>CocoaPods</code>，这将会确保 通过你在的<code>Gemfile</code>中指定<code>cocoapods gem</code>的版本后，<code>pods</code>可以被正确的安装。</p>
<p>感谢<a href="https://twitter.com/NeoNacho" target="_blank" rel="external">@NeoNacho</a>提供的小技巧。</p>
<p><strong>更新：</strong> 关于如何在你的项目中使用<code>Gemfile</code>的消息，请参阅<a href="https://guides.cocoapods.org/using/a-gemfile.html" target="_blank" rel="external">Cocoapods Guide on Using a Gemfile</a>。感谢<a href="https://twitter.com/orta/status/677972879988932608" target="_blank" rel="external">@orta</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/12/28/CocoaPod的小技巧/#more" class="more-link"><i class="fa fa-chevron-right"></i>查看全文</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://iJack.pw/2015/12/28/CocoaPod的小技巧/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/12/28/CocoaPod的小技巧/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-12-26T01:54:45.000Z"><a href="/2015/12/25/新的开始/">Fri, Dec 25 2015, 8:54:45 pm</a></time>

  
    <h1 class="title"><a href="/2015/12/25/新的开始/">新的开始</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/碎碎念/">碎碎念</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <hr>
<p>人生活在希望之中，</p>
<p>一个希望破灭了或实现了，</p>
<p>就一定会有新的希望产生。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/12/25/新的开始/#more" class="more-link"><i class="fa fa-chevron-right"></i>查看全文</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://iJack.pw/2015/12/25/新的开始/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/12/25/新的开始/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev"><i class="fa fa-long-arrow-left">上一页</i></a>
  
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js"></script>
<script src="/js/cover.js"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2017 Jack Alan
  
</div>
Powered by <a href="http://iJack.pw/" title="Jack Alan" target="_blank" rel="external">Jack Alan</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div>

<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Ffe3ef7effe40ca4903cec1453f5c809f' type='text/javascript'%3E%3C/script%3E"));
</script>

 What ?
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254084718'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1254084718%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
<OBJECT style="border: 0px" type="text/x-scriptlet" data="" width=0 Height=0 ></OBJECT>
 </footer>
  
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"ijack"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'https://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>



</body>
</html>